# Architecture Decisions Index (YAML Database)
#
# This YAML file serves as the central index/registry for all architecture decisions in the project.
# Each top-level key is a semantic token (e.g., ARCH-STDD_STRUCTURE).
#
# To append a new architecture decision:
# 1. Copy the template block at the bottom of this file (ARCH-IDENTIFIER)
# 2. Paste it at the end with a blank line before it
# 3. Replace ARCH-IDENTIFIER with your new token
# 4. Fill in all fields
# 5. Update the detail_file path to match your new .md file in architecture-decisions/ directory
#
# Field descriptions:
#   name: Short descriptive name of the decision
#   status: Active | Deprecated | Template | Superseded
#   cross_references: List of REQ-* tokens this decision fulfills
#   rationale: Structured explanation with why, problems_solved, benefits
#   alternatives_considered: List of alternative items with pros, cons, rejected_reason
#   implementation_approach: Structured approach with summary and details
#   traceability: Structured links to requirements, implementation, tests, code_annotations
#   related_decisions: Lists of depends_on, informs, see_also (YAML lists or [])
#   detail_file: Path to the detailed .md file in architecture-decisions/ directory
#   metadata: Structured metadata with created, last_updated, last_validated info
ARCH-STDD_STRUCTURE:
  name: STDD Project Structure
  status: Active
  cross_references:
    - REQ-STDD_SETUP
  rationale:
    why: "Keeps documentation close to code but organized in a dedicated namespace"
    problems_solved:
      - "Documentation scattered across project"
      - "Difficulty finding all context in one place"
      - "Meta-documentation mixed with source code"
    benefits:
      - "Clear separation of concerns"
      - "Standard project layout for AI agents"
      - "Easy discovery of all STDD documentation"
      - "Testable and maintainable structure"
  alternatives_considered:
    - name: "Root-level files"
      pros:
        - "Immediately visible in repository root"
      cons:
        - "Clutters the root directory"
        - "No clear organization"
      rejected_reason: "Creates too much clutter at project root"
    - name: ".github or .docs folder"
      pros:
        - "Common convention for documentation"
      cons:
        - "Too generic for methodology-specific files"
        - ".github is typically for GitHub workflows"
      rejected_reason: "stdd/ is more specific to the methodology"
  implementation_approach:
    summary: "Create dedicated stdd/ directory with YAML indexes and detail subdirectories"
    details:
      - "Create stdd/ directory at project root"
      - "Populate with YAML index files: requirements.yaml, architecture-decisions.yaml, implementation-decisions.yaml"
      - "Create detail subdirectories: requirements/, architecture-decisions/, implementation-decisions/"
      - "Add guide files: semantic-tokens.md, tasks.md, processes.md"
  traceability:
    requirements:
      - REQ-STDD_SETUP
    implementation:
      - IMPL-STDD_FILES
    tests:
      - TestSTDDSetup_REQ_STDD_SETUP
    code_annotations:
      - IMPL-STDD_FILES
      - ARCH-STDD_STRUCTURE
      - REQ-STDD_SETUP
  related_decisions:
    depends_on:
      - REQ-STDD_SETUP
    informs:
      - IMPL-STDD_FILES
    see_also: []
  detail_file: architecture-decisions/ARCH-STDD_STRUCTURE.md
  metadata:
    created:
      date: 2025-12-18
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2025-12-18
      validator: "AI Agent"
      result: "pass"
ARCH-MODULE_VALIDATION:
  name: Module Validation Strategy
  status: Active
  cross_references:
    - REQ-MODULE_VALIDATION
  rationale:
    why: "To eliminate bugs related to code complexity by ensuring each module works correctly in isolation"
    problems_solved:
      - "Integration complexity causing difficult-to-debug issues"
      - "Bugs discovered too late in development cycle"
      - "Module contracts not properly validated"
    benefits:
      - "Bugs caught early before integration"
      - "Reduced integration complexity"
      - "Easier debugging by isolating issues"
      - "Enables parallel module development"
      - "Clear module boundaries and contracts"
  alternatives_considered:
    - name: "Big Bang Integration"
      pros:
        - "Faster initial integration"
      cons:
        - "Too complex to debug"
        - "Bugs compound during integration"
        - "Difficult to isolate issues"
      rejected_reason: "Makes debugging too difficult and bugs compound"
    - name: "Minimal Validation"
      pros:
        - "Faster development cycle"
      cons:
        - "Insufficient to catch complexity bugs"
        - "Doesn't validate contracts properly"
      rejected_reason: "Insufficient validation leads to integration issues"
    - name: "Post-Integration Validation Only"
      pros:
        - "All validation done at once"
      cons:
        - "Doesn't catch module-level bugs early"
        - "Increases debugging complexity"
      rejected_reason: "Bugs discovered too late, making fixes expensive"
  implementation_approach:
    summary: "Independent module validation before integration with comprehensive testing strategy"
    details:
      - "Identify modules and document boundaries before development"
      - "Define module interfaces and contracts explicitly"
      - "Specify validation criteria for each module"
      - "Unit test modules with mocked dependencies"
      - "Integration test with test doubles (mocks, stubs, fakes)"
      - "Validate contracts (input/output validation)"
      - "Test edge cases and error handling"
      - "Document validation results before integration"
      - "Only integrate after validation passes"
  traceability:
    requirements:
      - REQ-MODULE_VALIDATION
    implementation:
      - IMPL-MODULE_VALIDATION
    tests:
      - testModuleName_IndependentValidation_REQ_MODULE_VALIDATION
    code_annotations:
      - IMPL-MODULE_VALIDATION
      - REQ-MODULE_VALIDATION
  related_decisions:
    depends_on:
      - REQ-MODULE_VALIDATION
    informs:
      - IMPL-MODULE_VALIDATION
    see_also: []
  detail_file: architecture-decisions/ARCH-MODULE_VALIDATION.md
  metadata:
    created:
      date: 2025-12-18
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2025-12-18
      validator: "AI Agent"
      result: "pass"
ARCH-NEXTJS_FRAMEWORK:
  name: Next.js 16.1 Framework Choice
  status: Active
  cross_references:
    - REQ-APP_STRUCTURE
    - REQ-BUILD_SYSTEM
  rationale:
    why: "Next.js provides best-in-class React framework with server components, optimized builds, and excellent developer experience"
    problems_solved:
      - "Complex React setup and configuration"
      - "Manual routing implementation"
      - "Server-side rendering complexity"
    benefits:
      - "File-based routing system"
      - "Server components by default"
      - "Excellent performance optimizations"
      - "Strong TypeScript support"
  alternatives_considered:
    - name: "Create React App"
      pros:
        - "Simple setup"
      cons:
        - "No SSR support"
        - "Limited optimization"
      rejected_reason: "Lacks server-side rendering and modern features"
    - name: "Remix"
      pros:
        - "Good SSR support"
      cons:
        - "Smaller ecosystem"
      rejected_reason: "Next.js has larger ecosystem and better tooling"
  implementation_approach:
    summary: "Use Next.js 16.1+ with App Router pattern"
    details:
      - "Install Next.js 16.1+ with React 19"
      - "Use App Router (src/app/ directory)"
      - "Enable server components by default"
      - "Configure TypeScript strict mode"
  traceability:
    requirements:
      - REQ-APP_STRUCTURE
      - REQ-BUILD_SYSTEM
    implementation:
      - IMPL-ROOT_LAYOUT
      - IMPL-HOME_PAGE
      - IMPL-BUILD_SCRIPTS
    tests:
      - Integration tests
    code_annotations:
      - REQ-APP_STRUCTURE
  related_decisions:
    depends_on:
      - REQ-APP_STRUCTURE
    informs:
      - ARCH-APP_ROUTER
      - ARCH-REACT_VERSION
    see_also: []
  detail_file: architecture-decisions/ARCH-NEXTJS_FRAMEWORK.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-REACT_VERSION:
  name: React 19.2 with Server Components
  status: Active
  cross_references:
    - REQ-APP_STRUCTURE
  rationale:
    why: "React 19 provides server components, improved performance, and modern features"
    problems_solved:
      - "Client-side rendering overhead"
      - "Waterfall data fetching"
    benefits:
      - "Server components reduce bundle size"
      - "Better performance"
      - "Modern React features"
  alternatives_considered: []
  implementation_approach:
    summary: "Use React 19.2 with Next.js App Router"
    details:
      - "Install React 19.2"
      - "Use server components by default"
      - "Client components only when needed"
  traceability:
    requirements:
      - REQ-APP_STRUCTURE
    implementation:
      - IMPL-HOME_PAGE
    tests:
      - Component tests
    code_annotations:
      - REQ-APP_STRUCTURE
  related_decisions:
    depends_on:
      - ARCH-NEXTJS_FRAMEWORK
    informs:
      - ARCH-SERVER_COMPONENTS
    see_also: []
  detail_file: architecture-decisions/ARCH-REACT_VERSION.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-TYPESCRIPT_LANG:
  name: TypeScript for Type Safety
  status: Active
  cross_references:
    - REQ-TYPESCRIPT
  rationale:
    why: "TypeScript provides compile-time type checking and improved developer experience"
    problems_solved:
      - "Runtime type errors"
      - "Poor IDE support"
      - "Lack of type safety"
    benefits:
      - "Compile-time error detection"
      - "Better IDE intelligence"
      - "Self-documenting code"
      - "Easier refactoring"
  alternatives_considered:
    - name: "JavaScript with JSDoc"
      pros:
        - "No compilation step"
      cons:
        - "Weaker type checking"
      rejected_reason: "TypeScript provides stronger guarantees"
  implementation_approach:
    summary: "Use TypeScript with strict mode enabled"
    details:
      - "Enable strict mode in tsconfig.json"
      - "Type all components and functions"
      - "Use Next.js types"
  traceability:
    requirements:
      - REQ-TYPESCRIPT
    implementation:
      - All TypeScript files
    tests:
      - TypeScript compilation
    code_annotations:
      - REQ-TYPESCRIPT
  related_decisions:
    depends_on:
      - REQ-TYPESCRIPT
    informs: []
    see_also: []
  detail_file: architecture-decisions/ARCH-TYPESCRIPT_LANG.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-TAILWIND_V4:
  name: Tailwind CSS v4 Styling System
  status: Active
  cross_references:
    - REQ-TAILWIND_STYLING
  rationale:
    why: "Tailwind v4 provides utility-first CSS with excellent performance and developer experience"
    problems_solved:
      - "CSS naming complexity"
      - "Large CSS bundles"
      - "Inconsistent styling"
    benefits:
      - "Rapid development"
      - "Small CSS bundles"
      - "Consistent design tokens"
      - "Excellent purging"
  alternatives_considered:
    - name: "CSS Modules"
      pros:
        - "Component-scoped styles"
      cons:
        - "More boilerplate"
      rejected_reason: "Tailwind is more efficient for utility-first approach"
  implementation_approach:
    summary: "Use Tailwind CSS v4 with PostCSS"
    details:
      - "Install Tailwind CSS v4"
      - "Configure PostCSS"
      - "Use @theme directive for custom tokens"
      - "Enable purging for production"
  traceability:
    requirements:
      - REQ-TAILWIND_STYLING
    implementation:
      - IMPL-FLEX_LAYOUT
    tests:
      - Styling tests
    code_annotations:
      - REQ-TAILWIND_STYLING
  related_decisions:
    depends_on:
      - REQ-TAILWIND_STYLING
    informs:
      - ARCH-RESPONSIVE_FIRST
    see_also: []
  detail_file: architecture-decisions/ARCH-TAILWIND_V4.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-APP_ROUTER:
  name: Next.js App Router Pattern
  status: Active
  cross_references:
    - REQ-APP_STRUCTURE
  rationale:
    why: "App Router provides modern routing with server components and improved data fetching"
    problems_solved:
      - "Complex Pages Router patterns"
      - "Client-side routing overhead"
    benefits:
      - "File-based routing"
      - "Server components by default"
      - "Improved data fetching"
  alternatives_considered:
    - name: "Pages Router"
      pros:
        - "More stable"
      cons:
        - "Older pattern"
      rejected_reason: "App Router is the future of Next.js"
  implementation_approach:
    summary: "Use App Router with src/app/ directory"
    details:
      - "Create src/app/ directory"
      - "Use layout.tsx for layouts"
      - "Use page.tsx for routes"
  traceability:
    requirements:
      - REQ-APP_STRUCTURE
    implementation:
      - IMPL-ROOT_LAYOUT
      - IMPL-HOME_PAGE
    tests:
      - Route tests
    code_annotations:
      - REQ-APP_STRUCTURE
  related_decisions:
    depends_on:
      - ARCH-NEXTJS_FRAMEWORK
    informs:
      - ARCH-SERVER_COMPONENTS
    see_also: []
  detail_file: architecture-decisions/ARCH-APP_ROUTER.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-LAYOUT_PATTERN:
  name: Root Layout Pattern
  status: Active
  cross_references:
    - REQ-ROOT_LAYOUT
  rationale:
    why: "Root layouts enable shared UI, consistent styling, and centralized metadata"
    problems_solved:
      - "Code duplication across pages"
      - "Inconsistent styling"
    benefits:
      - "Shared UI across routes"
      - "Centralized font loading"
      - "Consistent metadata"
  alternatives_considered: []
  implementation_approach:
    summary: "Create root layout at src/app/layout.tsx"
    details:
      - "Export default RootLayout function"
      - "Include html and body tags"
      - "Apply font variables"
      - "Export metadata"
  traceability:
    requirements:
      - REQ-ROOT_LAYOUT
    implementation:
      - IMPL-ROOT_LAYOUT
    tests:
      - Layout tests
    code_annotations:
      - REQ-ROOT_LAYOUT
  related_decisions:
    depends_on:
      - ARCH-APP_ROUTER
    informs:
      - IMPL-ROOT_LAYOUT
    see_also: []
  detail_file: architecture-decisions/ARCH-LAYOUT_PATTERN.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-SERVER_COMPONENTS:
  name: Server Components as Default
  status: Active
  cross_references:
    - REQ-APP_STRUCTURE
  rationale:
    why: "Server components reduce bundle size and improve performance"
    problems_solved:
      - "Large client bundles"
      - "Slow initial page loads"
    benefits:
      - "Smaller bundles"
      - "Faster page loads"
      - "Better SEO"
  alternatives_considered: []
  implementation_approach:
    summary: "Use server components by default, client components only when needed"
    details:
      - "All components are server components by default"
      - "Add 'use client' directive only for interactivity"
  traceability:
    requirements:
      - REQ-APP_STRUCTURE
    implementation:
      - IMPL-HOME_PAGE
    tests:
      - Component tests
    code_annotations:
      - REQ-APP_STRUCTURE
  related_decisions:
    depends_on:
      - ARCH-REACT_VERSION
    informs: []
    see_also: []
  detail_file: architecture-decisions/ARCH-SERVER_COMPONENTS.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-CSS_VARIABLES:
  name: CSS Variables for Dark Mode Theming
  status: Active
  cross_references:
    - REQ-DARK_MODE
    - REQ-GLOBAL_STYLES
  rationale:
    why: "CSS variables enable dynamic theming and runtime color changes"
    problems_solved:
      - "Static color definitions"
      - "Difficult theme switching"
    benefits:
      - "Runtime theme changes"
      - "Consistent color usage"
      - "Simple dark mode implementation"
  alternatives_considered: []
  implementation_approach:
    summary: "Define CSS variables in globals.css with prefers-color-scheme"
    details:
      - "Define --background and --foreground variables"
      - "Use prefers-color-scheme media query"
      - "Apply variables to body element"
  traceability:
    requirements:
      - REQ-DARK_MODE
      - REQ-GLOBAL_STYLES
    implementation:
      - IMPL-DARK_MODE
    tests:
      - Dark mode tests
    code_annotations:
      - REQ-DARK_MODE
  related_decisions:
    depends_on:
      - REQ-DARK_MODE
    informs:
      - IMPL-DARK_MODE
    see_also: []
  detail_file: architecture-decisions/ARCH-CSS_VARIABLES.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-RESPONSIVE_FIRST:
  name: Mobile-First Responsive Design
  status: Active
  cross_references:
    - REQ-RESPONSIVE_DESIGN
  rationale:
    why: "Mobile-first ensures good performance on smaller devices with progressive enhancement"
    problems_solved:
      - "Poor mobile experience"
      - "Desktop-first performance issues"
    benefits:
      - "Better mobile performance"
      - "Progressive enhancement"
      - "Meets user expectations"
  alternatives_considered: []
  implementation_approach:
    summary: "Use Tailwind breakpoints with mobile-first approach"
    details:
      - "Default styles for mobile"
      - "Use sm:, md:, lg: for larger screens"
      - "Test at 320px, 768px, 1024px"
  traceability:
    requirements:
      - REQ-RESPONSIVE_DESIGN
    implementation:
      - IMPL-RESPONSIVE_CLASSES
    tests:
      - Responsive tests
    code_annotations:
      - REQ-RESPONSIVE_DESIGN
  related_decisions:
    depends_on:
      - ARCH-TAILWIND_V4
    informs:
      - IMPL-RESPONSIVE_CLASSES
    see_also: []
  detail_file: architecture-decisions/ARCH-RESPONSIVE_FIRST.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-GOOGLE_FONTS:
  name: Google Fonts Optimization with next/font
  status: Active
  cross_references:
    - REQ-FONT_SYSTEM
  rationale:
    why: "next/font provides automatic font optimization without layout shift"
    problems_solved:
      - "Font loading causing layout shift"
      - "Large font files"
    benefits:
      - "No layout shift"
      - "Automatic subsetting"
      - "Preloading"
  alternatives_considered: []
  implementation_approach:
    summary: "Use next/font/google for Geist fonts"
    details:
      - "Import fonts with next/font/google"
      - "Enable subsetting (latin)"
      - "Create CSS variables"
  traceability:
    requirements:
      - REQ-FONT_SYSTEM
    implementation:
      - IMPL-FONT_LOADING
    tests:
      - Font loading tests
    code_annotations:
      - REQ-FONT_SYSTEM
  related_decisions:
    depends_on:
      - REQ-FONT_SYSTEM
    informs:
      - IMPL-FONT_LOADING
    see_also: []
  detail_file: architecture-decisions/ARCH-GOOGLE_FONTS.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-CSS_VARIABLES_FONTS:
  name: CSS Variables for Font Assignment
  status: Active
  cross_references:
    - REQ-FONT_SYSTEM
  rationale:
    why: "CSS variables enable flexible font application throughout the application"
    problems_solved:
      - "Direct font name references"
      - "Difficult font changes"
    benefits:
      - "Flexible font application"
      - "Easy font swapping"
  alternatives_considered: []
  implementation_approach:
    summary: "Create CSS variables for font families"
    details:
      - "Create --font-geist-sans variable"
      - "Create --font-geist-mono variable"
      - "Apply to body element"
  traceability:
    requirements:
      - REQ-FONT_SYSTEM
    implementation:
      - IMPL-FONT_LOADING
    tests:
      - Font tests
    code_annotations:
      - REQ-FONT_SYSTEM
  related_decisions:
    depends_on:
      - ARCH-GOOGLE_FONTS
    informs:
      - IMPL-FONT_LOADING
    see_also: []
  detail_file: architecture-decisions/ARCH-CSS_VARIABLES_FONTS.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-TEST_FRAMEWORK:
  name: Vitest Testing Framework
  status: Active
  cross_references:
    - REQ-BUILD_SYSTEM
  rationale:
    why: "Vitest provides fast test execution with excellent developer experience"
    problems_solved:
      - "Slow test execution"
      - "Complex test setup"
    benefits:
      - "Fast test runs"
      - "Great developer experience"
      - "Vite integration"
  alternatives_considered:
    - name: "Jest"
      pros:
        - "More mature"
      cons:
        - "Slower"
      rejected_reason: "Vitest is faster and has better DX"
  implementation_approach:
    summary: "Use Vitest with React Testing Library"
    details:
      - "Install Vitest and @testing-library/react"
      - "Configure vitest.config.ts"
      - "Set up test utilities"
      - "Enable coverage with 80% threshold"
  traceability:
    requirements:
      - REQ-BUILD_SYSTEM
    implementation:
      - IMPL-TEST_CONFIG
      - IMPL-TEST_SETUP
    tests:
      - All test files
    code_annotations:
      - REQ-BUILD_SYSTEM
  related_decisions:
    depends_on:
      - REQ-BUILD_SYSTEM
    informs:
      - IMPL-TEST_CONFIG
    see_also: []
  detail_file: architecture-decisions/ARCH-TEST_FRAMEWORK.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-CONFIG_DRIVEN_UI:
  name: YAML Configuration-Driven UI Architecture
  status: Active
  cross_references:
    - REQ-CONFIG_DRIVEN_UI
  rationale:
    why: "Configuration-driven UI makes the project a highly-configurable template"
    problems_solved:
      - "Hard-coded UI values"
      - "Difficult customization"
      - "Code changes for appearance"
    benefits:
      - "Easy customization via YAML"
      - "Separation of concerns"
      - "Template reusability"
      - "No code changes needed"
  alternatives_considered:
    - name: "Environment variables"
      pros:
        - "Simple"
      cons:
        - "Limited structure"
      rejected_reason: "YAML provides better structure and readability"
  implementation_approach:
    summary: "Two YAML config files (site.yaml, theme.yaml) with typed loader and deep merge"
    details:
      - "Create config/site.yaml for content"
      - "Create config/theme.yaml for styling"
      - "Build typed config loader with deep merge"
      - "Support partial configs with defaults"
  traceability:
    requirements:
      - REQ-CONFIG_DRIVEN_UI
    implementation:
      - IMPL-YAML_CONFIG
      - IMPL-CONFIG_LOADER
    tests:
      - Config loader tests
    code_annotations:
      - REQ-CONFIG_DRIVEN_UI
  related_decisions:
    depends_on:
      - REQ-CONFIG_DRIVEN_UI
    informs:
      - ARCH-THEME_INJECTION
      - ARCH-CLASS_OVERRIDES
    see_also: []
  detail_file: architecture-decisions/ARCH-CONFIG_DRIVEN_UI.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-THEME_INJECTION:
  name: CSS Variable Injection from Theme Config
  status: Active
  cross_references:
    - REQ-CONFIG_DRIVEN_UI
  rationale:
    why: "Inject CSS variables from theme config to enable runtime theming"
    problems_solved:
      - "Static theme colors"
      - "Hard-coded CSS variables"
    benefits:
      - "Runtime theming"
      - "Config-driven colors"
  alternatives_considered: []
  implementation_approach:
    summary: "Inject CSS variables in root layout from theme config"
    details:
      - "Read theme config in layout"
      - "Generate CSS variable string"
      - "Inject via style attribute"
  traceability:
    requirements:
      - REQ-CONFIG_DRIVEN_UI
    implementation:
      - IMPL-THEME_INJECTION
    tests:
      - Theme injection tests
    code_annotations:
      - REQ-CONFIG_DRIVEN_UI
  related_decisions:
    depends_on:
      - ARCH-CONFIG_DRIVEN_UI
    informs:
      - IMPL-THEME_INJECTION
    see_also:
      - ARCH-CSS_VARIABLES
  detail_file: architecture-decisions/ARCH-THEME_INJECTION.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-CLASS_OVERRIDES:
  name: Tailwind Class Override System via Config
  status: Active
  cross_references:
    - REQ-CONFIG_DRIVEN_UI
  rationale:
    why: "Allow per-element Tailwind class overrides through configuration"
    problems_solved:
      - "Hard-coded component classes"
      - "Difficult styling customization"
    benefits:
      - "Flexible styling"
      - "No code changes for styling"
  alternatives_considered: []
  implementation_approach:
    summary: "Use tailwind-merge to apply config-driven class overrides"
    details:
      - "Define class overrides in theme config"
      - "Use tailwind-merge to merge classes"
      - "Apply to components"
  traceability:
    requirements:
      - REQ-CONFIG_DRIVEN_UI
    implementation:
      - IMPL-CLASS_OVERRIDES
    tests:
      - Class override tests
    code_annotations:
      - REQ-CONFIG_DRIVEN_UI
  related_decisions:
    depends_on:
      - ARCH-CONFIG_DRIVEN_UI
    informs:
      - IMPL-CLASS_OVERRIDES
    see_also:
      - ARCH-TAILWIND_V4
  detail_file: architecture-decisions/ARCH-CLASS_OVERRIDES.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-CONFIG_DRIVEN_APPEARANCE:
  name: Config-Driven Appearance for All Pages
  status: Active
  cross_references:
    - REQ-CONFIG_DRIVEN_APPEARANCE
    - REQ-CONFIG_DRIVEN_UI
  rationale:
    why: "Extend config-driven architecture to all pages for complete template configurability"
    problems_solved:
      - "Incomplete template configurability"
      - "Hard-coded classes in some components"
    benefits:
      - "Complete template configurability"
      - "Consistent config-driven approach"
  alternatives_considered: []
  implementation_approach:
    summary: "Extend config system to jobs pages with dedicated jobs config and theme overrides"
    details:
      - "Add jobs config loader"
      - "Extend theme with jobs overrides"
      - "Refactor jobs components to use config"
  traceability:
    requirements:
      - REQ-CONFIG_DRIVEN_APPEARANCE
    implementation:
      - IMPL-CONFIG_DRIVEN_APPEARANCE
    tests:
      - Config-driven appearance tests
    code_annotations:
      - REQ-CONFIG_DRIVEN_APPEARANCE
  related_decisions:
    depends_on:
      - ARCH-CONFIG_DRIVEN_UI
    informs:
      - IMPL-CONFIG_DRIVEN_APPEARANCE
    see_also: []
  detail_file: architecture-decisions/ARCH-CONFIG_DRIVEN_APPEARANCE.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-JOB_TRACKER_STORAGE:
  name: Job Tracker YAML Storage Architecture
  status: Active
  cross_references:
    - REQ-JOB_TRACKER_DATA
    - REQ-JOB_TRACKER_STATUS
  rationale:
    why: "YAML storage maintains consistency with config architecture and provides version-controllable data"
    problems_solved:
      - "Database complexity"
      - "Data not version-controllable"
    benefits:
      - "Simple storage"
      - "Human-readable"
      - "Version-controllable"
  alternatives_considered:
    - name: "JSON files"
      pros:
        - "JavaScript native"
      cons:
        - "Less readable"
      rejected_reason: "YAML is more readable and consistent with config files"
  implementation_approach:
    summary: "Store job data in data/jobs.yaml with config-driven schema"
    details:
      - "Define schema in config/jobs.yaml"
      - "Store data in data/jobs.yaml"
      - "Provide typed data layer"
  traceability:
    requirements:
      - REQ-JOB_TRACKER_DATA
    implementation:
      - IMPL-JOBS_DATA
    tests:
      - Job data tests
    code_annotations:
      - REQ-JOB_TRACKER_DATA
  related_decisions:
    depends_on:
      - REQ-JOB_TRACKER_DATA
    informs:
      - IMPL-JOBS_DATA
    see_also:
      - ARCH-CONFIG_DRIVEN_UI
  detail_file: architecture-decisions/ARCH-JOB_TRACKER_STORAGE.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-JOB_TRACKER_UI:
  name: Job Tracker UI Page Architecture
  status: Active
  cross_references:
    - REQ-JOB_TRACKER_LIST
    - REQ-JOB_TRACKER_EDIT
  rationale:
    why: "Server components for list/edit pages with config-driven UI"
    problems_solved:
      - "Client-side data fetching"
      - "Hard-coded UI"
    benefits:
      - "Server-side rendering"
      - "Config-driven UI"
  alternatives_considered: []
  implementation_approach:
    summary: "Server component pages with config-driven components"
    details:
      - "List page at /jobs"
      - "Edit page at /jobs/[id]/edit"
      - "Use config for all UI elements"
  traceability:
    requirements:
      - REQ-JOB_TRACKER_LIST
      - REQ-JOB_TRACKER_EDIT
    implementation:
      - IMPL-JOBS_LIST_PAGE
      - IMPL-JOBS_EDIT_PAGE
    tests:
      - Page tests
    code_annotations:
      - REQ-JOB_TRACKER_LIST
  related_decisions:
    depends_on:
      - ARCH-CONFIG_DRIVEN_APPEARANCE
    informs:
      - IMPL-JOBS_LIST_PAGE
    see_also: []
  detail_file: architecture-decisions/ARCH-JOB_TRACKER_UI.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-JOB_TRACKER_API:
  name: Job Tracker API Route Architecture
  status: Active
  cross_references:
    - REQ-JOB_TRACKER_CRUD
  rationale:
    why: "API routes provide RESTful interface for CRUD operations"
    problems_solved:
      - "Direct file manipulation from client"
      - "No centralized data operations"
    benefits:
      - "Centralized CRUD logic"
      - "RESTful interface"
      - "Data validation"
  alternatives_considered: []
  implementation_approach:
    summary: "API routes at /api/jobs with GET/POST/PUT/DELETE support"
    details:
      - "Create API routes in app/api/jobs/"
      - "Support CRUD operations"
      - "Use jobs data layer"
  traceability:
    requirements:
      - REQ-JOB_TRACKER_CRUD
    implementation:
      - IMPL-JOBS_API
    tests:
      - API tests
    code_annotations:
      - REQ-JOB_TRACKER_CRUD
  related_decisions:
    depends_on:
      - ARCH-JOB_TRACKER_STORAGE
    informs:
      - IMPL-JOBS_API
    see_also: []
  detail_file: architecture-decisions/ARCH-JOB_TRACKER_API.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-CALENDAR_VIEW:
  name: Calendar View Architecture
  status: Active
  cross_references:
    - REQ-JOB_TRACKER_CALENDAR
  rationale:
    why: "Provide visual timeline of job search activity with month-at-a-glance view"
    problems_solved:
      - "No visual timeline"
      - "Difficulty seeing patterns"
    benefits:
      - "Visual timeline"
      - "Pattern identification"
      - "Complements table view"
  alternatives_considered: []
  implementation_approach:
    summary: "Server component page with client component calendar grid"
    details:
      - "Page at /jobs/calendar"
      - "Server component loads data"
      - "Client component for interactivity"
      - "Config-driven UI elements"
  traceability:
    requirements:
      - REQ-JOB_TRACKER_CALENDAR
    implementation:
      - IMPL-CALENDAR_PAGE
      - IMPL-CALENDAR_GRID
    tests:
      - Calendar tests
    code_annotations:
      - REQ-JOB_TRACKER_CALENDAR
  related_decisions:
    depends_on:
      - ARCH-JOB_TRACKER_STORAGE
      - ARCH-CONFIG_DRIVEN_APPEARANCE
    informs:
      - IMPL-CALENDAR_PAGE
    see_also: []
  detail_file: architecture-decisions/ARCH-CALENDAR_VIEW.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-YAML_DATA_STORAGE:
  name: YAML Data Storage Pattern
  status: Active
  cross_references:
    - REQ-JOB_TRACKER_DATA
  rationale:
    why: "YAML provides human-readable, version-controllable data storage"
    problems_solved:
      - "Database complexity"
      - "Binary data formats"
    benefits:
      - "Human-readable"
      - "Version-controllable"
      - "Simple to use"
  alternatives_considered: []
  implementation_approach:
    summary: "Store data in YAML files in data/ directory"
    details:
      - "Create data/ directory"
      - "Store records in YAML format"
      - "Use YAML parser for read/write"
  traceability:
    requirements:
      - REQ-JOB_TRACKER_DATA
    implementation:
      - IMPL-JOBS_DATA
    tests:
      - Data storage tests
    code_annotations:
      - REQ-JOB_TRACKER_DATA
  related_decisions:
    depends_on:
      - REQ-JOB_TRACKER_DATA
    informs:
      - ARCH-JOB_TRACKER_STORAGE
    see_also:
      - ARCH-CONFIG_DRIVEN_UI
  detail_file: architecture-decisions/ARCH-YAML_DATA_STORAGE.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-CONFIG_DRIVEN_CRUD:
  name: Config-Driven CRUD Architecture
  status: Active
  cross_references:
    - REQ-JOB_TRACKER_DATA
  rationale:
    why: "Extends config-driven architecture to CRUD features with schema-driven forms and tables"
    problems_solved:
      - "Hard-coded form fields"
      - "Hard-coded table columns"
    benefits:
      - "Schema-driven UI"
      - "Flexible data models"
  alternatives_considered: []
  implementation_approach:
    summary: "Define schema in config, generate forms and tables dynamically"
    details:
      - "Schema in config/jobs.yaml"
      - "Dynamic form generation"
      - "Dynamic table generation"
  traceability:
    requirements:
      - REQ-JOB_TRACKER_DATA
    implementation:
      - IMPL-JOBS_DATA
    tests:
      - CRUD tests
    code_annotations:
      - REQ-JOB_TRACKER_DATA
  related_decisions:
    depends_on:
      - ARCH-CONFIG_DRIVEN_UI
    informs:
      - IMPL-JOBS_DATA
    see_also:
      - ARCH-JOB_TRACKER_STORAGE
  detail_file: architecture-decisions/ARCH-CONFIG_DRIVEN_CRUD.md
  metadata:
    created:
      date: 2025-11-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-06
      author: "AI Agent"
      reason: "Migration to v1.5.0"
    last_validated:
      date: 2026-02-06
      validator: "AI Agent"
      result: "pass"
ARCH-FILE_MANAGER_HIERARCHY:
  name: File Manager Component Hierarchy
  status: Active
  cross_references:
    - REQ-FILE_MANAGER_PAGE
    - REQ-MULTI_PANE_LAYOUT
  rationale:
    why: "Three-tier hierarchy (Page → Workspace → Pane) separates concerns and follows existing project patterns"
    problems_solved:
      - "Monolithic file manager component"
      - "Difficult state management"
      - "Poor testability"
    benefits:
      - "Clear separation of concerns"
      - "Server/client component split"
      - "Independent testing of layers"
      - "Reusable pane components"
  alternatives_considered:
    - name: "Single-component approach"
      pros:
        - "Simpler initial implementation"
      cons:
        - "Poor testability"
        - "Difficult state management"
      rejected_reason: "Doesn't scale to multi-pane complexity"
  implementation_approach:
    summary: "Server page loads data, client workspace manages panes, file pane displays content"
    details:
      - "FilesPage (server component) - loads initial directory data and config"
      - "WorkspaceView (client component) - manages pane state, layout, focus"
      - "FilePane (client component) - displays files, handles pane-level interactions"
      - "Follow calendar view pattern from existing codebase"
  traceability:
    requirements:
      - REQ-FILE_MANAGER_PAGE
      - REQ-MULTI_PANE_LAYOUT
    implementation:
      - IMPL-FILE_MANAGER_PAGE
      - IMPL-WORKSPACE_VIEW
      - IMPL-FILE_PANE
    tests:
      - File manager hierarchy tests
    code_annotations:
      - ARCH-FILE_MANAGER_HIERARCHY
  related_decisions:
    depends_on:
      - ARCH-SERVER_COMPONENTS
      - ARCH-NEXTJS_FRAMEWORK
    informs:
      - IMPL-FILE_MANAGER_PAGE
      - IMPL-WORKSPACE_VIEW
    see_also:
      - ARCH-CALENDAR_VIEW
  detail_file: ""
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Initial creation"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass"
ARCH-LAYOUT_ALGORITHMS:
  name: Multi-Pane Layout Algorithms
  status: Active
  cross_references:
    - REQ-MULTI_PANE_LAYOUT
  rationale:
    why: "Geometric layout calculations optimize screen space for different file management tasks"
    problems_solved:
      - "Manual pane positioning"
      - "Inconsistent layouts"
      - "Inefficient screen space usage"
    benefits:
      - "Automatic pane allocation"
      - "Consistent layouts"
      - "Optimal space utilization"
  alternatives_considered:
    - name: "CSS Grid/Flexbox only"
      pros:
        - "Native CSS solution"
      cons:
        - "Limited layout flexibility"
        - "Difficult dynamic layouts"
      rejected_reason: "Cannot support all Goful layout types"
  implementation_approach:
    summary: "Pure TypeScript functions calculate absolute pane bounds based on layout type"
    details:
      - "Tile: First pane left 50%, others stacked vertically right 50%"
      - "OneRow: All panes equal width horizontally"
      - "OneColumn: All panes equal height vertically"
      - "Fullscreen: All panes overlap, only focused visible"
      - "Return PaneBounds[] with x, y, width, height for each pane"
  traceability:
    requirements:
      - REQ-MULTI_PANE_LAYOUT
    implementation:
      - IMPL-LAYOUT_CALCULATOR
    tests:
      - Layout algorithm tests
    code_annotations:
      - ARCH-LAYOUT_ALGORITHMS
  related_decisions:
    depends_on:
      - REQ-MULTI_PANE_LAYOUT
    informs:
      - IMPL-LAYOUT_CALCULATOR
    see_also:
      - ARCH-FILE_MANAGER_HIERARCHY
  detail_file: ""
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Initial creation"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass"
ARCH-COMPARISON_INDEX:
  name: Cross-Pane File Comparison Index
  status: Active
  cross_references:
    - REQ-CROSS_PANE_COMPARISON
  rationale:
    why: "Centralized index enables efficient cross-pane file comparison and state tracking"
    problems_solved:
      - "Inefficient pairwise comparisons"
      - "Scattered comparison logic"
      - "Difficult to maintain comparison state"
    benefits:
      - "O(1) lookup for comparison state"
      - "Single source of truth"
      - "Easy to rebuild on pane changes"
  alternatives_considered:
    - name: "On-demand comparison"
      pros:
        - "No pre-computation"
      cons:
        - "Slow for large directories"
        - "Repeated calculations"
      rejected_reason: "Performance issues with large file lists"
  implementation_approach:
    summary: "Build Map<filename, CompareState[]> index from all pane contents"
    details:
      - "CompareState tracks which panes have the file, sizes, mtimes"
      - "Build index when panes change (navigate, reload)"
      - "Pane components query index for each file"
      - "Color coding: yellow (same name), red/green (size/time diff)"
  traceability:
    requirements:
      - REQ-CROSS_PANE_COMPARISON
    implementation:
      - IMPL-COMPARISON_INDEX
    tests:
      - Comparison index tests
    code_annotations:
      - ARCH-COMPARISON_INDEX
  related_decisions:
    depends_on:
      - REQ-CROSS_PANE_COMPARISON
    informs:
      - IMPL-COMPARISON_INDEX
    see_also:
      - ARCH-FILE_MANAGER_HIERARCHY
  detail_file: ""
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Initial creation"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass"
ARCH-FILESYSTEM_ABSTRACTION:
  name: Server-Side Filesystem Abstraction
  status: Active
  cross_references:
    - REQ-DIRECTORY_NAVIGATION
    - REQ-FILE_OPERATIONS
  rationale:
    why: "Server-side filesystem access via data layer ensures security and follows Next.js best practices"
    problems_solved:
      - "Client-side filesystem access impossible"
      - "Security vulnerabilities from direct fs access"
      - "Difficult testing"
    benefits:
      - "Secure server-side access"
      - "Testable with mocks"
      - "Consistent API"
  alternatives_considered:
    - name: "Client-side File System Access API"
      pros:
        - "Native browser support"
      cons:
        - "Limited to user's local files"
        - "Not server filesystem"
      rejected_reason: "Requirement is server filesystem browsing"
  implementation_approach:
    summary: "Data layer module (files.data.ts) wraps Node.js fs/promises API"
    details:
      - "Use fs/promises for async operations"
      - "Server-only module (not imported by client components)"
      - "Path validation to prevent directory traversal"
      - "Error handling for permissions, non-existent paths"
  traceability:
    requirements:
      - REQ-DIRECTORY_NAVIGATION
      - REQ-FILE_OPERATIONS
    implementation:
      - IMPL-FILES_DATA
    tests:
      - Filesystem data layer tests
    code_annotations:
      - ARCH-FILESYSTEM_ABSTRACTION
  related_decisions:
    depends_on:
      - ARCH-NEXTJS_FRAMEWORK
    informs:
      - IMPL-FILES_DATA
    see_also:
      - ARCH-JOB_TRACKER_STORAGE
  detail_file: ""
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Initial creation"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass"
ARCH-FILE_OPERATIONS_API:
  name: File Operations API Routes
  status: Active
  cross_references:
    - REQ-FILE_OPERATIONS
  rationale:
    why: "API routes provide secure server-side file operations accessible from client"
    problems_solved:
      - "Client cannot perform filesystem operations"
      - "Security vulnerabilities from client-side access"
      - "No centralized error handling"
    benefits:
      - "Secure server-side operations"
      - "Centralized validation and error handling"
      - "RESTful interface"
  alternatives_considered:
    - name: "Server actions"
      pros:
        - "Simpler than API routes"
      cons:
        - "Tied to forms"
        - "Less flexible for programmatic calls"
      rejected_reason: "API routes more flexible for file operations"
  implementation_approach:
    summary: "POST /api/files endpoint handles copy, move, delete, rename operations"
    details:
      - "Request body: { operation, src, dest }"
      - "Switch on operation type"
      - "Call data layer functions"
      - "Return success/error responses"
  traceability:
    requirements:
      - REQ-FILE_OPERATIONS
    implementation:
      - IMPL-FILES_API
    tests:
      - File operations API tests
    code_annotations:
      - ARCH-FILE_OPERATIONS_API
  related_decisions:
    depends_on:
      - ARCH-FILESYSTEM_ABSTRACTION
    informs:
      - IMPL-FILES_API
    see_also:
      - ARCH-JOB_TRACKER_API
  detail_file: ""
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Initial creation"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass"
ARCH-SERVER_CLIENT_BOUNDARY:
  name: Server-Client Code Boundary Separation
  status: Active
  cross_references:
    - REQ-FILE_MANAGER_PAGE
    - REQ-DIRECTORY_NAVIGATION
  rationale:
    why: "Prevent Node.js modules from being bundled into client JavaScript and maintain correct API route paths"
    problems_solved:
      - "Build errors from fs/promises in client bundle"
      - "Unclear boundaries between server and client code"
      - "Accidental server code imports in client components"
      - "404 errors from mismatched API routes and client calls"
    benefits:
      - "Clear architectural boundary"
      - "Prevents build-time errors"
      - "Easier to reason about code dependencies"
      - "Follows Next.js best practices"
      - "Correct API route URLs aligned with file structure"
  alternatives_considered:
    - name: "Mark files as server-only with 'server-only' package"
      pros:
        - "Explicit marker"
        - "Build-time enforcement"
      cons:
        - "Still need separate utility files"
        - "Extra dependency"
      rejected_reason: "Adds dependency without solving the utility sharing problem"
    - name: "Use dynamic imports in client code"
      pros:
        - "Can import server code conditionally"
      cons:
        - "Doesn't work for server-only modules like fs"
        - "Adds runtime complexity"
      rejected_reason: "Cannot dynamically import Node.js built-in modules in browser"
  implementation_approach:
    summary: "Separate server-only code and client-safe utilities into different files; align API routes with Next.js App Router conventions"
    details:
      - "files.data.ts: Server-only, imports fs/promises, path, os"
      - "files.utils.ts: Client-safe, pure TypeScript with no Node.js dependencies"
      - "files.types.ts: Shared types, no runtime code"
      - "Server components and API routes import from files.data.ts"
      - "Client components import only from files.utils.ts"
      - "files.data.ts can re-export utilities from files.utils.ts for convenience"
      - "Import traces in build errors reveal exactly where server code leaks into client"
      - "API routes follow Next.js convention: src/app/api/files/route.ts creates /api/files endpoint (not /api/files/list)"
      - "Client code must call exact API route URLs matching file structure"
  traceability:
    requirements:
      - REQ-FILE_MANAGER_PAGE
      - REQ-DIRECTORY_NAVIGATION
    implementation:
      - IMPL-FILES_DATA
      - IMPL-FILES_UTILS
      - IMPL-FILE_PANE
      - IMPL-WORKSPACE_VIEW
      - IMPL-FILES_API
    tests:
      - Production build verification
      - API route integration tests
    code_annotations:
      - ARCH-SERVER_CLIENT_BOUNDARY
  related_decisions:
    depends_on: []
    informs:
      - IMPL-FILES_DATA
      - IMPL-FILES_UTILS
      - IMPL-FILES_API
      - IMPL-WORKSPACE_VIEW
    see_also:
      - ARCH-FILESYSTEM_ABSTRACTION
      - ARCH-FILE_MANAGER_HIERARCHY
      - ARCH-FILE_OPERATIONS_API
  detail_file: ""
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Added API route URL alignment lesson; fixed 404 error from /api/files/list vs /api/files mismatch"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass"
ARCH-LOGGING_SYSTEM:
  name: Session-Based File Logging Architecture
  status: Active
  cross_references:
    - REQ-LOGGING_SYSTEM
  rationale:
    why: "Persistent file-based logging enables debugging across sessions and temporal analysis"
    problems_solved:
      - "Ephemeral console logs"
      - "No historical debugging data"
      - "Difficult to trace issues in production"
    benefits:
      - "Persistent logs survive restarts"
      - "Session-based files enable temporal analysis"
      - "OS temp directory automatic cleanup"
  alternatives_considered:
    - name: "Console-only logging"
      pros:
        - "Simple to implement"
        - "No file management"
      cons:
        - "Ephemeral, lost after session"
        - "Cannot analyze historical data"
      rejected_reason: "Does not meet requirement for debugging facilitation"
    - name: "Database logging"
      pros:
        - "Queryable logs"
        - "Structured data"
      cons:
        - "Requires database setup"
        - "Performance overhead"
        - "Overkill for simple debugging"
      rejected_reason: "Too complex for initial implementation"
    - name: "External logging service"
      pros:
        - "Professional solution"
        - "Advanced features"
      cons:
        - "External dependency"
        - "Cost"
        - "Privacy concerns"
      rejected_reason: "Prefer self-contained solution"
  implementation_approach:
    summary: "Write timestamped log files to OS temp directory with six log levels"
    details:
      - "Use Node.js os.tmpdir() for temporary directory"
      - "Filename format: nx1-log-YYYY-MM-DD-HH-mm-ss-SSS.log"
      - "Log levels: FATAL (0), ERROR (1), WARN (2), INFO (3), DEBUG (4), TRACE (5)"
      - "Format: [TIMESTAMP] [LEVEL] [TOKENS] message"
      - "Synchronous writes for reliability (fatal errors)"
      - "Buffered writes for performance (non-fatal)"
  traceability:
    requirements:
      - REQ-LOGGING_SYSTEM
    implementation:
      - IMPL-LOGGER_MODULE
    tests:
      - Logger system tests
    code_annotations:
      - ARCH-LOGGING_SYSTEM
  related_decisions:
    depends_on: []
    informs:
      - IMPL-LOGGER_MODULE
    see_also:
      - ARCH-LOGGING_CONFIG
  detail_file: ""
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Initial creation"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass"
ARCH-LOGGING_CONFIG:
  name: Environment-Based Logging Configuration
  status: Active
  cross_references:
    - REQ-LOGGING_CONFIG
  rationale:
    why: "Environment variables enable runtime configuration without code changes"
    problems_solved:
      - "Hard-coded logging behavior"
      - "Cannot adjust logging in production"
      - "Different needs for dev vs prod"
    benefits:
      - "Runtime configuration"
      - "Environment-specific behavior"
      - "No code changes needed"
  alternatives_considered:
    - name: "YAML config file"
      pros:
        - "Structured configuration"
        - "Consistent with project patterns"
      cons:
        - "Requires file deployment"
        - "Cannot change without restart"
      rejected_reason: "Less flexible than environment variables"
    - name: "Hard-coded with build-time flags"
      pros:
        - "No runtime overhead"
      cons:
        - "Requires rebuild to change"
        - "Not suitable for debugging"
      rejected_reason: "Too inflexible for debugging use case"
  implementation_approach:
    summary: "Read environment variables with sensible defaults at module initialization"
    details:
      - "ENABLE_LOGGING: 'true' | 'false' (default: 'true')"
      - "LOG_LEVEL: 'FATAL' | 'ERROR' | 'WARN' | 'INFO' | 'DEBUG' | 'TRACE' (default: 'INFO')"
      - "LOG_DIR: custom directory path (default: os.tmpdir())"
      - "CONSOLE_ERRORS: 'true' | 'false' (default: 'true') - Mirror ERROR/FATAL to console"
      - "Initialize once at module load"
      - "Validate environment variables with fallbacks"
      - "Output log file path to console on initialization"
      - "Mirror ERROR and FATAL logs to console.error() by default"
  traceability:
    requirements:
      - REQ-LOGGING_CONFIG
    implementation:
      - IMPL-LOGGER_CONFIG
    tests:
      - Logger config tests
    code_annotations:
      - ARCH-LOGGING_CONFIG
  related_decisions:
    depends_on:
      - ARCH-LOGGING_SYSTEM
    informs:
      - IMPL-LOGGER_CONFIG
    see_also: []
  detail_file: ""
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Initial creation"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass"
ARCH-LOGGING_SEMANTIC_TOKENS:
  name: Semantic Token Integration in Logging
  status: Active
  cross_references:
    - REQ-LOGGING_SEMANTIC_TOKENS
  rationale:
    why: "Semantic tokens in logs enable complete traceability from runtime to requirements"
    problems_solved:
      - "Cannot trace logs to feature requirements"
      - "Unclear which module generated log"
      - "No connection to STDD documentation"
    benefits:
      - "Complete end-to-end traceability"
      - "Easy grep/search by token"
      - "Connects runtime behavior to design docs"
  alternatives_considered:
    - name: "Module name only (no tokens)"
      pros:
        - "Simpler API"
        - "Less verbose"
      cons:
        - "No requirement traceability"
        - "Cannot track feature-level activity"
      rejected_reason: "Does not meet STDD traceability requirements"
    - name: "Optional tokens"
      pros:
        - "Flexible"
      cons:
        - "Easy to forget"
        - "Inconsistent usage"
      rejected_reason: "Tokens must be mandatory for STDD compliance"
  implementation_approach:
    summary: "Logger API requires tokens parameter as string or array of strings"
    details:
      - "tokens: string | string[] - required parameter"
      - "Format tokens as space-separated in log output"
      - "Validate token format [REQ-*], [ARCH-*], [IMPL-*]"
      - "TypeScript types enforce token presence at compile time"
      - "Log format: [TIMESTAMP] [LEVEL] [TOKEN1] [TOKEN2] message"
  traceability:
    requirements:
      - REQ-LOGGING_SEMANTIC_TOKENS
    implementation:
      - IMPL-LOGGER_TOKENS
    tests:
      - Semantic token tests
    code_annotations:
      - ARCH-LOGGING_SEMANTIC_TOKENS
  related_decisions:
    depends_on:
      - ARCH-LOGGING_SYSTEM
    informs:
      - IMPL-LOGGER_TOKENS
    see_also:
      - ARCH-STDD_STRUCTURE
  detail_file: ""
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Initial creation"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass"
ARCH-MARKING_STATE:
  name: Client-Side Mark State Management
  status: Active
  cross_references:
    - REQ-FILE_MARKING_WEB
  rationale:
    why: "Web file marking requires client-side state for instant feedback with name-based persistence"
    problems_solved:
      - "Server-side mark storage adds latency"
      - "Mark state lost on page refresh"
      - "Complex synchronization between client and server"
    benefits:
      - "Instant mark toggle feedback"
      - "Simple Set<string> storage in React state"
      - "Name-based persistence survives re-sorts"
      - "Independent mark sets per pane"
  alternatives_considered:
    - name: "Server-side mark storage in session"
      pros:
        - "Persists across page refresh"
      cons:
        - "Network latency on every mark toggle"
        - "Complex session management"
      rejected_reason: "Latency unacceptable for interactive marking"
    - name: "Index-based marking"
      pros:
        - "Simple integer storage"
      cons:
        - "Breaks when files re-sorted"
      rejected_reason: "Name-based survives sort changes"
  implementation_approach:
    summary: "React state with Set<string> per pane, name-based persistence"
    details:
      - "PaneState interface includes marks: Set<string> field"
      - "Mark operations: toggle, markAll, invertMarks, clearMarks"
      - "Visual feedback: checkbox icon + background color from theme.yaml"
      - "Footer display: [marked/total] format"
      - "Batch operations check marks.size > 0"
  traceability:
    requirements:
      - REQ-FILE_MARKING_WEB
    implementation:
      - IMPL-FILE_MARKING
    tests:
      - testMarkingState_ARCH_MARKING_STATE
    code_annotations:
      - ARCH-MARKING_STATE
  related_decisions:
    depends_on:
      - REQ-FILE_MARKING_WEB
    informs:
      - IMPL-FILE_MARKING
    see_also:
      - ARCH-BATCH_OPERATIONS
  detail_file: architecture-decisions/ARCH-MARKING_STATE.md
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Initial creation - translated from Goful for web"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass"
ARCH-BATCH_OPERATIONS:
  name: Async Batch File Operations Architecture
  status: Active
  cross_references:
    - REQ-BULK_FILE_OPS
  rationale:
    why: "Batch operations need async execution with progress tracking and error handling"
    problems_solved:
      - "Blocking UI during long operations"
      - "No progress visibility"
      - "Poor error recovery"
    benefits:
      - "Non-blocking UI with Promise.all"
      - "Real-time progress callbacks"
      - "Graceful error handling with partial success"
      - "Cross-pane operation support"
  alternatives_considered:
    - name: "Sequential operations"
      pros:
        - "Simpler implementation"
      cons:
        - "Slower for large file sets"
      rejected_reason: "Parallel operations significantly faster"
    - name: "Server-side job queue"
      pros:
        - "Survives page refresh"
      cons:
        - "Complex job management infrastructure"
      rejected_reason: "Over-engineered for current needs"
  implementation_approach:
    summary: "Promise.all with progress callbacks, fallback to cursor file"
    details:
      - "Check marks.size > 0, use marked files; else use cursor file"
      - "POST /api/files with operation: bulk-copy/bulk-move/bulk-delete"
      - "Server streams progress updates via callbacks"
      - "Progress dialog shows: percentage, file count, current file"
      - "Error collection: continue on error, report at end"
  traceability:
    requirements:
      - REQ-BULK_FILE_OPS
    implementation:
      - IMPL-BULK_OPS
    tests:
      - testBatchOps_ARCH_BATCH_OPERATIONS
    code_annotations:
      - ARCH-BATCH_OPERATIONS
  related_decisions:
    depends_on:
      - ARCH-MARKING_STATE
    informs:
      - IMPL-BULK_OPS
    see_also:
      - ARCH-SERVER_CLIENT_BOUNDARY
  detail_file: architecture-decisions/ARCH-BATCH_OPERATIONS.md
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Initial creation - adapted from Goful ARCH-ASYNC_FILE_OPERATIONS"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass"
ARCH-DIRECTORY_HISTORY:
  name: Per-Directory Cursor Position History
  status: Implemented
  cross_references:
    - REQ-ADVANCED_NAV
  rationale:
    why: "Maintain user context when navigating directory trees"
    problems_solved:
      - "Lost cursor position when revisiting directories"
      - "No breadcrumb on parent navigation"
      - "Disorientation in deep directory trees"
    benefits:
      - "Filename-based restoration survives file changes"
      - "Parent navigation shows previous subdirectory"
      - "Session-scoped history (simple Map storage)"
      - "Separate history per pane"
  alternatives_considered:
    - name: "Index-based history"
      pros:
        - "Simpler storage (just number)"
      cons:
        - "Breaks when files added/removed"
      rejected_reason: "Filename-based more robust"
    - name: "localStorage persistence"
      pros:
        - "Survives page refresh"
      cons:
        - "Complexity, stale data issues"
      rejected_reason: "Session-only sufficient"
  implementation_approach:
    summary: "Map<pane_id, Map<path, {cursor, scrollTop}>> in React state"
    details:
      - "Save cursor position before directory change"
      - "Restore cursor position on revisit by filename match"
      - "Parent navigation: search for previous dir name in parent list"
      - "LRU cache for recent directories (last 20)"
  traceability:
    requirements:
      - REQ-ADVANCED_NAV
    implementation:
      - IMPL-DIR_HISTORY
    tests:
      - testDirHistory_ARCH_DIRECTORY_HISTORY
    code_annotations:
      - ARCH-DIRECTORY_HISTORY
  related_decisions:
    depends_on:
      - REQ-ADVANCED_NAV
    informs:
      - IMPL-DIR_HISTORY
    see_also:
      - ARCH-MARKING_STATE
  detail_file: architecture-decisions/ARCH-DIRECTORY_HISTORY.md
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Initial creation - adapted from Goful ARCH-DIRECTORY_HISTORY"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass"
ARCH-COMPARISON_COLORING:
  name: Enhanced Cross-Pane Comparison Coloring
  status: Implemented
  cross_references:
    - REQ-FILE_COMPARISON_VISUAL
  rationale:
    why: "Visual size/time comparison enables instant file relationship identification"
    problems_solved:
      - "Existing comparison only shows presence/absence"
      - "Cannot identify newest or largest versions"
      - "Manual size/time comparison required"
    benefits:
      - "Instant visual size comparison (equal/smallest/largest)"
      - "Instant visual time comparison (equal/earliest/latest)"
      - "Configurable color scheme in theme.yaml"
      - "Automatic rebuild on pane changes"
  alternatives_considered:
    - name: "Server-side comparison"
      pros:
        - "Less client computation"
      cons:
        - "Network latency on every pane change"
      rejected_reason: "Client-side faster for typical file counts"
    - name: "On-demand comparison (button click)"
      pros:
        - "No automatic overhead"
      cons:
        - "Extra user action required"
      rejected_reason: "Automatic comparison is core feature"
  implementation_approach:
    summary: "Extend ComparisonIndex with size/time analysis, apply CSS classes"
    details:
      - "buildEnhancedComparisonIndex: For each filename in multiple panes, compute sizeClass and timeClass"
      - "sizeClass: 'equal' | 'smallest' | 'largest' | null"
      - "timeClass: 'equal' | 'earliest' | 'latest' | null"
      - "Apply CSS classes to file rows based on comparison state"
      - "Theme colors: comparison-equal, comparison-smallest, comparison-largest, etc."
  traceability:
    requirements:
      - REQ-FILE_COMPARISON_VISUAL
    implementation:
      - IMPL-COMPARISON_COLORS
    tests:
      - testComparisonColoring_ARCH_COMPARISON_COLORING
    code_annotations:
      - ARCH-COMPARISON_COLORING
  related_decisions:
    depends_on:
      - REQ-CROSS_PANE_COMPARISON
    informs:
      - IMPL-COMPARISON_COLORS
    see_also:
      - ARCH-CONFIG_DRIVEN_UI
  detail_file: architecture-decisions/ARCH-COMPARISON_COLORING.md
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Initial creation - adapted from Goful ARCH-FILE_COMPARISON_ENGINE"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass"
ARCH-SEARCH_ENGINE:
  name: Dual-Mode Search Engine (Incremental + Content)
  status: Implemented
  cross_references:
    - REQ-FILE_SEARCH
  rationale:
    why: "Different search modes for different use cases: quick filename filtering vs deep content search"
    problems_solved:
      - "Filename search too slow if searching content"
      - "Content search too heavy for simple filtering"
      - "No unified search interface"
    benefits:
      - "Incremental finder: client-side, instant feedback"
      - "Content search: server-side, comprehensive"
      - "Regex support in both modes"
      - "Search history for repeated patterns"
  alternatives_considered:
    - name: "All client-side search"
      pros:
        - "No API calls, instant results"
      cons:
        - "Cannot load file contents in browser"
      rejected_reason: "Cannot search file contents safely"
    - name: "All server-side search"
      pros:
        - "Consistent architecture"
      cons:
        - "Network latency for simple filtering"
      rejected_reason: "Incremental finder needs instant feedback"
  implementation_approach:
    summary: "Hybrid: client-side file finder + server-side content search"
    components:
      - name: "File Finder (Client)"
        description: "Fuzzy matches against visible file list"
        file: "src/app/files/components/FinderDialog.tsx"
      - name: "Content Search (Server)"
        description: "Reads files and searches contents with pattern"
        file: "src/app/api/files/search/route.ts"
      - name: "Search History"
        description: "LocalStorage persistence for recent searches"
        file: "src/lib/files.search.ts (SearchHistory class)"
  key_design_decisions:
    - decision: "Search algorithm"
      choice: "Fuzzy substring matching for files, regex for content"
    - decision: "History storage"
      choice: "LocalStorage with LRU cache (max 20)"
    - decision: "Security"
      choice: "Server-side path validation and regex DoS prevention"
  traceability:
    requirements:
      - REQ-FILE_SEARCH
    implementation:
      - IMPL-FILE_SEARCH
    tests:
      - src/lib/files.search.test.ts
      - src/app/api/files/search/route.test.ts
      - src/app/files/components/FinderDialog.test.tsx
      - src/app/files/components/SearchDialog.test.tsx
    code_annotations:
      - ARCH-SEARCH_ENGINE
  related_decisions:
    depends_on:
      - REQ-FILE_SEARCH
    informs:
      - IMPL-FILE_SEARCH
    see_also:
      - ARCH-SERVER_CLIENT_BOUNDARY
  detail_file: architecture-decisions/ARCH-SEARCH_ENGINE.md
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Phase 8 completed - all components implemented and tested (124 tests)"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass - 523 total tests passing"
  alternatives_considered:
    - name: "Single unified search"
      pros:
        - "Simpler UI"
      cons:
        - "Performance trade-offs unclear"
      rejected_reason: "Different use cases need different strategies"
    - name: "Client-side content search"
      pros:
        - "No server round-trip"
      cons:
        - "Must download all file contents"
      rejected_reason: "Bandwidth prohibitive"
  implementation_approach:
    summary: "Client-side incremental finder + server-side content search API"
    details:
      - "Incremental finder: Ctrl+F, client-side fuzzy/regex match on visible files"
      - "Content search: Ctrl+Shift+F, POST /api/files/search with pattern"
      - "Both support regex with auto case-insensitive"
      - "Search history: localStorage, last 20 patterns"
      - "Results: filename, line number, context snippet"
  traceability:
    requirements:
      - REQ-FILE_SEARCH
    implementation:
      - IMPL-FILE_SEARCH
    tests:
      - testSearchEngine_ARCH_SEARCH_ENGINE
    code_annotations:
      - ARCH-SEARCH_ENGINE
  related_decisions:
    depends_on:
      - REQ-FILE_SEARCH
    informs:
      - IMPL-FILE_SEARCH
    see_also:
      - ARCH-SERVER_CLIENT_BOUNDARY
  detail_file: architecture-decisions/ARCH-SEARCH_ENGINE.md
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Initial creation - adapted from Goful ARCH-FINDER_OVERLAY"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass"
ARCH-PREVIEW_SYSTEM:
  name: Server-Side File Preview Rendering
  status: Active
  cross_references:
    - REQ-FILE_PREVIEW
  rationale:
    why: "File preview requires server-side content access and security checks"
    problems_solved:
      - "Cannot access file contents from client"
      - "No security validation of file types"
      - "Large files overwhelm browser memory"
    benefits:
      - "Server controls file access and security"
      - "Content sanitization before sending to client"
      - "Efficient streaming for large files"
      - "Support for text, image, archive types"
  alternatives_considered:
    - name: "Client-side preview"
      pros:
        - "No server round-trip"
      cons:
        - "Cannot access server filesystem"
      rejected_reason: "Impossible in web environment"
    - name: "Full file download"
      pros:
        - "Simple implementation"
      cons:
        - "Wasteful for large files"
      rejected_reason: "Preview needs only subset of content"
  implementation_approach:
    summary: "API routes for preview/info with type detection and content sanitization"
    details:
      - "GET /api/files/preview?path=...&type=text|image|archive"
      - "GET /api/files/info?path=... for detailed metadata"
      - "File type detection: extension + magic bytes"
      - "Text preview: first 100KB with encoding detection"
      - "Image preview: serve via Next.js Image optimization"
      - "Archive preview: list entries without extracting"
  traceability:
    requirements:
      - REQ-FILE_PREVIEW
    implementation:
      - IMPL-FILE_PREVIEW
    tests:
      - testPreviewSystem_ARCH_PREVIEW_SYSTEM
    code_annotations:
      - ARCH-PREVIEW_SYSTEM
  related_decisions:
    depends_on:
      - REQ-FILE_PREVIEW
    informs:
      - IMPL-FILE_PREVIEW
    see_also:
      - ARCH-SERVER_CLIENT_BOUNDARY
  detail_file: architecture-decisions/ARCH-PREVIEW_SYSTEM.md
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Initial creation - web-specific architecture"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass"
ARCH-KEYBIND_SYSTEM:
  name: Configurable Keyboard Binding Registry
  status: Implemented
  cross_references:
    - REQ-KEYBOARD_SHORTCUTS_COMPLETE
  rationale:
    why: "Comprehensive keyboard shortcuts need centralized registry with config-driven bindings"
    problems_solved:
      - "Scattered keyboard handlers across components"
      - "Hard-coded keybindings"
      - "No discoverability of shortcuts"
    benefits:
      - "Centralized keybind registry"
      - "Configurable via files.yaml"
      - "Help overlay auto-generated from registry"
      - "Command palette with fuzzy search"
  alternatives_considered:
    - name: "Component-level event handlers"
      pros:
        - "Simple, no abstraction"
      cons:
        - "Duplicate code, hard to configure"
      rejected_reason: "Doesn't scale to comprehensive system"
    - name: "Browser hotkeys library"
      pros:
        - "Mature implementation"
      cons:
        - "Extra dependency, limited customization"
      rejected_reason: "Custom solution more flexible"
  implementation_approach:
    summary: "Keybinding registry with action dispatch and config loading"
    components:
      - name: "Keybinding Registry"
        description: "Central registry of all keybindings loaded from YAML"
      - name: "Event Matcher"
        description: "Matches KeyboardEvent to action names"
      - name: "Action Handlers"
        description: "Map of action names to handler functions"
      - name: "Help Overlay"
        description: "Modal displaying all shortcuts by category"
      - name: "Command Palette"
        description: "Fuzzy search for actions"
  key_design_decisions:
    - decision: "Configuration format"
      choice: "YAML with key, modifiers, action, description, category"
    - decision: "Action naming"
      choice: "category.verb pattern (e.g., file.copy, navigate.up)"
    - decision: "Modifier handling"
      choice: "Support Ctrl, Shift, Alt, Meta with exact matching"
    - decision: "Category organization"
      choice: "7 fixed categories: navigation, file-operations, marking, view-sort, preview, advanced, system"
    - decision: "Server-client split"
      choice: "Config loaded on server, passed as props to client for registry initialization"
  detail_file: architecture-decisions/ARCH-KEYBIND_SYSTEM.md
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Phase 7 completed - all components implemented and tested"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass"
    details:
      - "Keybinding interface: key (string), action (string), description, category"
      - "Load keybindings from files.yaml at mount"
      - "Global keydown handler checks registry, dispatches actions"
      - "Help overlay renders from registry (grouped by category)"
      - "Command palette: fuzzy search by action/description"
  traceability:
    requirements:
      - REQ-KEYBOARD_SHORTCUTS_COMPLETE
    implementation:
      - IMPL-KEYBINDS
    tests:
      - testKeybindSystem_ARCH_KEYBIND_SYSTEM
    code_annotations:
      - ARCH-KEYBIND_SYSTEM
  related_decisions:
    depends_on:
      - REQ-KEYBOARD_SHORTCUTS_COMPLETE
      - REQ-CONFIG_DRIVEN_FILE_MANAGER
    informs:
      - IMPL-KEYBINDS
    see_also:
      - ARCH-CONFIG_DRIVEN_UI
  detail_file: architecture-decisions/ARCH-KEYBIND_SYSTEM.md
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Initial creation - web-specific architecture"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass"
ARCH-SORT_PIPELINE:
  name: Multi-Criteria Sort Pipeline Architecture
  status: Active
  cross_references:
    - REQ-FILE_SORTING_ADVANCED
  decision:
    summary: Client-side multi-criteria sort pipeline with comparator composition
    context: File manager needs flexible sorting by name, size, time, extension with ascending/descending order and directory prioritization
    decision: Implement composable sort pipeline with pluggable comparators
    consequences:
      positive:
        - Instant sort without server round-trip
        - Easy to add new sort criteria
        - Cursor preservation via filename tracking
        - Directory-first option for better navigation
      negative:
        - Client must handle all sorting logic
        - Memory overhead for large directories
      mitigations:
        - Efficient comparison functions
        - Consider virtualization for 1000+ files (Phase 12)
  alternatives_considered:
    - option: Server-side sorting
      pros:
        - Handles very large directories
        - Reduces client bundle size
      cons:
        - Network latency on every sort
        - More complex state management
      rejected_reason: User expects instant sort feedback; latency breaks UX
  traceability:
    requirements:
      - REQ-FILE_SORTING_ADVANCED
    implementation:
      - IMPL-SORT_FILTER
    tests:
      - testSorting_ARCH_SORT_PIPELINE
  detail_file: architecture-decisions/ARCH-SORT_PIPELINE.md
  metadata:
    created:
      date: "2026-02-07"
      author: AI Agent
    last_updated:
      date: "2026-02-07"
      author: AI Agent
      reason: Initial creation for Phase 5

ARCH-FILES_CONFIG_COMPLETE:
  name: Complete File Manager Configuration Architecture
  status: Active
  cross_references:
    - REQ-FILES_CONFIG_COMPLETE
    - REQ-CONFIG_DRIVEN_FILE_MANAGER
  rationale:
    why: "Complete configuration system enables full template customization without code changes"
    problems_solved:
      - "Hard-coded UI text and styling"
      - "Fixed layout and startup behavior"
      - "Non-customizable file type indicators"
      - "Incomplete configurability"
    benefits:
      - "Zero code changes for customization"
      - "Future internationalization ready"
      - "Easy A/B testing of configurations"
      - "Complete visual and behavioral control"
  alternatives_considered:
    - name: "Component-level configuration"
      pros:
        - "More granular control"
      cons:
        - "Complex to maintain"
        - "Scattered configuration"
      rejected_reason: "Centralized YAML config more maintainable"
    - name: "Database-driven configuration"
      pros:
        - "Runtime updates possible"
      cons:
        - "Requires database infrastructure"
        - "More complex setup"
      rejected_reason: "YAML file config simpler for template use case"
  implementation_approach:
    summary: "Extend existing YAML configuration with layout/startup/fileTypes sections and pattern-based matching"
    details:
      - "Extended config/files.yaml with layout and startup configuration"
      - "Extended config/theme.yaml with fileTypes (icon, color, patterns)"
      - "Added TypeScript interfaces for new sections"
      - "Implemented glob-to-regex pattern matching for file types"
      - "Extended defaults to handle missing configuration gracefully"
  traceability:
    requirements:
      - REQ-FILES_CONFIG_COMPLETE
      - REQ-CONFIG_DRIVEN_FILE_MANAGER
    implementation:
      - IMPL-FILES_CONFIG_COMPLETE
    tests:
      - testFilesConfig_ARCH_FILES_CONFIG_COMPLETE
    code_annotations:
      - ARCH-FILES_CONFIG_COMPLETE
  related_decisions:
    depends_on:
      - ARCH-CONFIG_DRIVEN_UI
    informs:
      - IMPL-FILES_CONFIG_COMPLETE
    see_also:
      - ARCH-KEYBIND_SYSTEM
      - ARCH-COMPARISON_COLORING
  detail_file: ""
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Phase 11 architecture complete"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass - 567 tests passing"

ARCH-MOUSE_SUPPORT:
  name: Mouse and Touch Interaction Architecture
  status: Active
  cross_references:
    - REQ-MOUSE_INTERACTION
  rationale:
    why: "Web users expect mouse and touch interactions for accessibility and familiar UX"
    problems_solved:
      - "Keyboard-only interface not accessible to all users"
      - "No context menu for operation discoverability"
      - "Cannot drag-drop files between panes"
    benefits:
      - "Right-click context menu provides operation discoverability"
      - "Drag-and-drop provides intuitive cross-pane file operations"
      - "Click to select matches desktop file manager UX"
      - "Touch-friendly for tablet users"
  alternatives_considered:
    - name: "Third-party drag-drop library"
      pros:
        - "Polished DX, handles edge cases"
      cons:
        - "Extra dependency, bundle size"
      rejected_reason: "HTML5 API sufficient"
    - name: "Custom context menu library"
      pros:
        - "Advanced features (submenus, icons)"
      cons:
        - "Dependency, configuration overhead"
      rejected_reason: "Simple portal component meets requirements"
  implementation_approach:
    summary: "Portal-based context menu, HTML5 drag-drop, existing click handlers"
    details:
      - "ContextMenu: Portal to document.body, position calculation, outside click dismiss"
      - "Drag-drop: HTML5 API with custom drag image and modifier key detection"
      - "Click: Existing onClick handlers (already implemented)"
      - "Double-click: Existing onDoubleClick handlers (already implemented)"
      - "Scroll: Native browser overflow-y-auto"
  traceability:
    requirements:
      - REQ-MOUSE_INTERACTION
    implementation:
      - IMPL-MOUSE_SUPPORT
    tests:
      - testMouseSupport_ARCH_MOUSE_SUPPORT
    code_annotations:
      - ARCH-MOUSE_SUPPORT
  related_decisions:
    depends_on:
      - ARCH-FILE_MANAGER_HIERARCHY
      - ARCH-FILE_OPERATIONS_API
    informs:
      - IMPL-MOUSE_SUPPORT
    see_also:
      - ARCH-KEYBIND_SYSTEM
  detail_file: architecture-decisions/ARCH-MOUSE_SUPPORT.md
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Phase 10 implementation complete"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass - 554 tests passing"
# ---
# Template Record - Copy this block to create new architecture decisions
# ---
#
# ARCH-IDENTIFIER:
#   name: Architecture Decision Title
#   status: Active
#   cross_references:
#     - REQ-RELATED_REQUIREMENT
#   rationale:
#     why: "Primary reason for this decision"
#     problems_solved:
#       - "Problem 1"
#       - "Problem 2"
#     benefits:
#       - "Benefit 1"
#       - "Benefit 2"
#   alternatives_considered:
#     - name: "Alternative 1"
#       pros:
#         - "Pro 1"
#       cons:
#         - "Con 1"
#       rejected_reason: "Why it was rejected"
#     - name: "Alternative 2"
#       pros:
#         - "Pro 1"
#       cons:
#         - "Con 1"
#       rejected_reason: "Why it was rejected"
#   implementation_approach:
#     summary: "High-level description of the approach"
#     details:
#       - "Key component 1"
#       - "Key component 2"
#       - "Integration point 1"
#   traceability:
#     requirements:
#       - REQ-IDENTIFIER
#     implementation:
#       - IMPL-IDENTIFIER
#     tests:
#       - testFeatureName_ARCH_IDENTIFIER
#     code_annotations:
#       - ARCH-IDENTIFIER
#   related_decisions:
#     depends_on: []
#     informs: []
#     see_also: []
#   detail_file: architecture-decisions/ARCH-IDENTIFIER.md
#   metadata:
#     created:
#       date: YYYY-MM-DD
#       author: "agent/contributor"
#     last_updated:
#       date: YYYY-MM-DD
#       author: "agent/contributor"
#       reason: "Initial creation"
#     last_validated:
#       date: YYYY-MM-DD
#       validator: "agent/contributor"
#       result: "pass"

ARCH-PANE_LIFECYCLE:
  name: Multi-Pane Initialization and Management
  status: Active
  cross_references:
    - REQ-MULTI_PANE_LAYOUT
    - REQ-FILES_CONFIG_COMPLETE
  rationale:
    why: "Defines how multiple file panes are initialized from configuration and managed at runtime to enable productive multi-panel file management workflows"
    problems_solved:
      - "File manager only initialized with single pane despite config specifying defaultPaneCount"
      - "No mechanism to add/remove panes dynamically at runtime"
      - "Startup paths configuration not respected"
      - "Users forced to work with single pane even when multi-panel layout configured"
    benefits:
      - "Configuration-driven pane initialization matching user preferences"
      - "Dynamic pane management for flexible workflows"
      - "Multiple startup modes (home, configured, last)"
      - "Respects layout constraints (maxPanes, allowPaneManagement)"
  alternatives_considered:
    - name: "Client-side initialization only"
      pros:
        - "Simpler server code"
        - "All logic in one place"
      cons:
        - "Requires multiple API calls to initialize each pane"
        - "Slower initial page load"
        - "Duplicated directory reading logic"
      rejected_reason: "Server-side initialization provides better performance and cleaner separation of concerns"
    - name: "Fixed pane count without runtime management"
      pros:
        - "Simpler state management"
        - "No need for add/remove logic"
      cons:
        - "Users cannot adjust layout to current task"
        - "Configuration changes require page reload"
      rejected_reason: "Runtime management enables flexible workflows without page reloads"
  implementation_approach:
    summary: "Server-side multi-pane initialization based on config, client-side pane management with keyboard shortcuts and config validation"
    details:
      - "Server page reads layout.defaultPaneCount and startup.mode from config"
      - "Server initializes array of PaneState objects with appropriate directories"
      - "Startup mode 'home': all panes start at user home directory"
      - "Startup mode 'configured': each pane starts at paths.pane1, pane2, etc."
      - "Startup mode 'last': future enhancement using localStorage"
      - "Client WorkspaceView receives initialPanes array instead of single path/files"
      - "Add pane: clones focused pane state or creates new pane at home directory"
      - "Remove pane: removes pane from array, adjusts focusIndex if necessary"
      - "Keyboard shortcuts (+ to add, - to remove) integrated with keybinding system"
      - "Config validation prevents adding beyond maxPanes or removing last pane"
  traceability:
    requirements:
      - REQ-MULTI_PANE_LAYOUT
      - REQ-FILES_CONFIG_COMPLETE
    implementation:
      - IMPL-PANE_MANAGEMENT
      - IMPL-WORKSPACE_VIEW
      - IMPL-FILE_MANAGER_PAGE
    tests:
      - testPaneInitialization_REQ_MULTI_PANE_LAYOUT
      - testPaneManagement_REQ_MULTI_PANE_LAYOUT
    code_annotations:
      - IMPL-PANE_MANAGEMENT
      - ARCH-PANE_LIFECYCLE
      - REQ-MULTI_PANE_LAYOUT
  related_decisions:
    depends_on:
      - ARCH-FILE_MANAGER_HIERARCHY
      - ARCH-CONFIG_DRIVEN_UI
    informs:
      - IMPL-PANE_MANAGEMENT
      - IMPL-FILE_MANAGER_PAGE
    see_also:
      - ARCH-LAYOUT_ALGORITHMS
  detail_file: architecture-decisions/ARCH-PANE_LIFECYCLE.md
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-07
      author: "AI Agent"
      reason: "Initial creation with type synchronization fix"
    last_validated:
      date: 2026-02-07
      validator: "AI Agent"
      result: "pass - build succeeds, 570 tests passing"

ARCH-PANE_REFRESH:
  name: Pane Refresh Architecture
  status: Active
  cross_references:
    - REQ-PANE_REFRESH
    - REQ-KEYBOARD_SHORTCUTS_COMPLETE
    - REQ-MULTI_PANE_LAYOUT
  rationale:
    why: "Reuse existing handleNavigate mechanism to refresh panes by re-fetching current directory, providing consistent state management and minimal code duplication"
    problems_solved:
      - "Stale directory listings from external file system changes"
      - "No dedicated refresh mechanism in original design"
      - "Need for both single-pane and all-pane refresh operations"
      - "Browser default refresh would reload entire page"
    benefits:
      - "Leverages existing, battle-tested handleNavigate logic"
      - "Preserves cursor position and sort settings automatically"
      - "Prevents browser default refresh with e.preventDefault()"
      - "Parallel refresh for all panes using Promise.all"
      - "Consistent with existing post-operation refresh pattern"
  alternatives_considered:
    - name: "Dedicated refresh API endpoint"
      pros:
        - "Explicit refresh semantics"
        - "Could implement optimized refresh logic"
      cons:
        - "Code duplication with navigation logic"
        - "Additional API endpoint to maintain"
        - "Would require separate state management"
      rejected_reason: "handleNavigate already provides all needed functionality"
    - name: "Auto-refresh with file system watchers"
      pros:
        - "Automatic updates without user intervention"
        - "Real-time file system synchronization"
      cons:
        - "Complex server-side implementation"
        - "Potential performance issues with large directories"
        - "Websocket or polling overhead"
        - "Unpredictable UI updates"
      rejected_reason: "Manual refresh is simpler and gives users control"
    - name: "F5 key for refresh"
      pros:
        - "Traditional browser refresh key"
      cons:
        - "Conflicts with browser default (full page reload)"
        - "Harder to prevent default behavior reliably"
        - "Less familiar in terminal-like interfaces"
      rejected_reason: "Ctrl+R is safer and more terminal-like"
  implementation_approach:
    summary: "Add pane.refresh and pane.refresh-all actions to keybinding system; handlers call handleNavigate with current path"
    details:
      - "Add two keybinding definitions to config/files.yaml (Ctrl+R, Ctrl+Shift+R)"
      - "Register actions in pane-management category"
      - "Single pane refresh: handleNavigate(focusIndex, currentPane.path)"
      - "All panes refresh: Promise.all(panes.map((p, idx) => handleNavigate(idx, p.path)))"
      - "Use void operator to handle async without blocking"
      - "handleNavigate already handles: API fetch, sort application, cursor restoration"
      - "Browser default prevented by existing e.preventDefault() in keyboard handler"
  traceability:
    requirements:
      - REQ-PANE_REFRESH
      - REQ-KEYBOARD_SHORTCUTS_COMPLETE
    implementation:
      - IMPL-PANE_REFRESH
      - IMPL-KEYBINDS
    tests:
      - Manual keystroke testing
    code_annotations:
      - ARCH-PANE_REFRESH
      - REQ-PANE_REFRESH
  related_decisions:
    depends_on:
      - ARCH-KEYBIND_SYSTEM
      - ARCH-PANE_LIFECYCLE
      - ARCH-FILE_MANAGER_HIERARCHY
    informs:
      - IMPL-PANE_REFRESH
    see_also:
      - ARCH-FILE_OPERATIONS_API
  detail_file: architecture-decisions/ARCH-PANE_REFRESH.md
  metadata:
    created:
      date: 2026-02-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-08
      author: "AI Agent"
      reason: "Initial creation"
    last_validated:
      date: 2026-02-08
      validator: "AI Agent"
      result: "pass"

ARCH-LINKED_NAV:
  name: Linked Pane Navigation Architecture
  status: Implemented
  cross_references:
    - REQ-LINKED_PANES
  rationale:
    why: "Synchronized directory navigation, cursor position, and sort order eliminates manual coordination overhead for comparison tasks while preserving independent pane state"
    problems_solved:
      - "Manual synchronization of multiple panes to same subdirectory"
      - "State complexity managing linked mode without interfering with existing pane state"
      - "Synchronization timing ensuring linked panes update together"
      - "Asymmetric directory handling when target doesn't exist in linked pane"
      - "Visual feedback indicating linked state"
      - "Cursor position synchronization for visual comparison"
      - "Sort order consistency across comparison panes"
      - "Auto-disable preventing broken sync state on divergence"
    benefits:
      - "Simple boolean toggle model (linkedMode state)"
      - "Automatic propagation via handleNavigate, handleCursorMove, handleSortChange"
      - "Minimal state overhead (single boolean + sync ref)"
      - "Clear visual indicators in footer and pane headers (🔗 badge)"
      - "Mouse-accessible parent navigation via .. button in pane header"
      - "Backward compatible (disabled by default)"
      - "Graceful degradation on partial failures"
      - "Complete feature parity with Goful implementation"
  alternatives_considered:
    - name: "Server-side link state"
      pros:
        - "Persists across page refreshes"
        - "Centralized state management"
      cons:
        - "Network latency on toggle"
        - "Requires session storage"
      rejected_reason: "Client-side state sufficient; session persistence not required"
    - name: "Link groups with UI configuration"
      pros:
        - "Maximum flexibility for advanced workflows"
      cons:
        - "Complex UI for group management"
        - "Unclear use case for most users"
      rejected_reason: "Defer to future enhancement; simple global toggle covers 90% of use cases"
    - name: "Automatic link detection"
      pros:
        - "No manual toggle needed"
      cons:
        - "Unpredictable behavior"
        - "Difficult to disable"
      rejected_reason: "Explicit user control provides predictability"
  implementation_approach:
    summary: "Boolean linkedMode state in WorkspaceView with L key toggle; handleNavigate propagates navigation, handleCursorMove syncs by filename, handleSortChange applies to all panes; auto-disable on divergence"
    details:
      - "Add linkedMode: boolean state to WorkspaceView"
      - "Add syncingRef: useRef<Set<number>> to track panes currently syncing"
      - "Modify handleNavigate to track success/failure counts and auto-disable on partial failure"
      - "Modify handleCursorMove to sync cursor by filename across all panes when linked"
      - "Modify handleSortChange to apply sort settings to all panes when linked"
      - "Relative path resolution: extract target directory name, append to each linked pane's current path"
      - "Existence check before navigating linked pane (graceful degradation on failure)"
      - "Link indicator badge in footer: 🔗 L: Linked (shows only with 2+ panes)"
      - "Link indicator badge in each pane header (🔗 shows when linked)"
      - "Parent .. button in each pane header (visible when not at root, respects linked mode)"
      - "L key toggle action in keybinding registry"
      - "Support subdirectory navigation, parent navigation (keyboard + mouse), cursor sync, sort sync"
      - "Auto-disable with warning message on navigation divergence"
  traceability:
    requirements:
      - REQ-LINKED_PANES
      - REQ-MULTI_PANE_LAYOUT
      - REQ-DIRECTORY_NAVIGATION
    implementation:
      - IMPL-LINKED_NAV
    tests:
      - TEST-LINKED_PANES
    code_annotations:
      - ARCH-LINKED_NAV
      - REQ-LINKED_PANES
      - IMPL-LINKED_NAV
  related_decisions:
    depends_on:
      - ARCH-FILE_MANAGER_HIERARCHY
      - ARCH-KEYBIND_SYSTEM
      - ARCH-SORT_PIPELINE
    informs:
      - IMPL-LINKED_NAV
    see_also:
      - ARCH-COMPARISON_INDEX
      - ARCH-DIRECTORY_HISTORY
  detail_file: architecture-decisions/ARCH-LINKED_NAV.md
  metadata:
    created:
      date: 2026-02-07
      author: "AI Agent"
    last_updated:
      date: 2026-02-09
      author: "AI Agent"
      reason: "Added Parent .. button in pane header for mouse-based parent navigation with automatic linked mode support"
    last_validated:
      date: 2026-02-08
      validator: "AI Agent"
      result: "pass"

ARCH-TOOLBAR_LAYOUT:
  name: Toolbar Positioning and Layout Architecture
  status: Implemented
  cross_references:
    - REQ-TOOLBAR_SYSTEM
    - REQ-TOOLBAR_CONFIG
  rationale:
    why: "Three-tier toolbar system with configurable positioning optimizes discoverability while preserving keyboard-first design"
    problems_solved:
      - "36+ operations overwhelming in single toolbar"
      - "No visual separation of action scopes"
      - "Fixed layout unsuitable for all use cases"
    benefits:
      - "Clear scope separation (workspace vs pane vs system)"
      - "Configuration-driven positioning"
      - "Responsive design for mobile/tablet/desktop"
      - "Minimal screen space consumption"
  alternatives_considered:
    - name: "Single unified toolbar"
      pros:
        - "Simpler implementation"
      cons:
        - "36+ buttons overwhelming"
        - "No scope separation"
      rejected_reason: "Visual separation critical for usability"
  implementation_approach:
    summary: "Three toolbar types (workspace, pane, system) with configurable position and button groups"
    details:
      - "WorkspaceToolbar: actions affecting all panes"
      - "PaneToolbar: actions on focused pane"
      - "SystemToolbar: independent actions"
      - "Configurable position: top, bottom, hidden, per-pane"
  traceability:
    requirements:
      - REQ-TOOLBAR_SYSTEM
      - REQ-TOOLBAR_CONFIG
    implementation:
      - IMPL-TOOLBAR_COMPONENT
    tests:
      - src/app/files/components/Toolbar.test.tsx
    code_annotations:
      - ARCH-TOOLBAR_LAYOUT
  related_decisions:
    depends_on:
      - ARCH-KEYBIND_SYSTEM
      - ARCH-CONFIG_DRIVEN_UI
    informs:
      - IMPL-TOOLBAR_COMPONENT
    see_also: []
  detail_file: architecture-decisions/ARCH-TOOLBAR_LAYOUT.md
  metadata:
    created:
      date: 2026-02-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-08
      author: "AI Agent"
      reason: "Initial creation"
    last_validated:
      date: 2026-02-08
      validator: "AI Agent"
      result: "planned"

ARCH-TOOLBAR_ACTIONS:
  name: Action-to-Button Mapping Architecture
  status: Implemented
  cross_references:
    - REQ-TOOLBAR_SYSTEM
    - REQ-KEYBOARD_SHORTCUTS_COMPLETE
  rationale:
    why: "Derive button metadata from keybinding registry to ensure consistency"
    problems_solved:
      - "Potential inconsistency between toolbar and keyboard"
      - "Code duplication of action handlers"
    benefits:
      - "Single source of truth"
      - "Zero duplication"
      - "Consistent behavior guaranteed"
  alternatives_considered:
    - name: "Separate button configuration"
      pros:
        - "Explicit control"
      cons:
        - "Duplication"
      rejected_reason: "Single source of truth critical"
  implementation_approach:
    summary: "Derive icon, label, keystroke from keybinding registry"
    details:
      - "ACTION_ICON_MAP for icon mapping"
      - "handleToolbarAction dispatch to existing handlers"
  traceability:
    requirements:
      - REQ-TOOLBAR_SYSTEM
    implementation:
      - IMPL-TOOLBAR_COMPONENT
    tests:
      - src/lib/toolbar.utils.test.ts
    code_annotations:
      - ARCH-TOOLBAR_ACTIONS
  related_decisions:
    depends_on:
      - ARCH-KEYBIND_SYSTEM
    informs:
      - IMPL-TOOLBAR_COMPONENT
    see_also: []
  detail_file: architecture-decisions/ARCH-TOOLBAR_ACTIONS.md
  metadata:
    created:
      date: 2026-02-08
      author: "AI Agent"
    last_updated:
      date: 2026-02-08
      author: "AI Agent"
      reason: "Initial creation"
    last_validated:
      date: 2026-02-08
      validator: "AI Agent"
      result: "planned"
